问题: 索引是什么概念有什么作用？MySQL里主要有哪些索引结构？哈希索引和B+树索引比较？

索引是什么概念有什么作用？
1、如果每次都需要取到所有表记录，无论如何都必须进行全表扫描了，那么是否加索引也没有意义了。
2、对非唯一的字段，例如“性别”这种大量重复值的字段，增加索引也没有什么意义。
3、对于记录比较少的表，增加索引不会带来速度的优化反而浪费了存储空间，因为索引是需要存储空间的，
    而且有个致命缺点是对于update/insert/delete的每次执行，字段的索引都必须重新计算更新。

MySQL里主要有哪些索引结构？
Mysql目前主要有以下几种索引类型：FULLTEXT，HASH，BTREE，RTREE。
1. FULLTEXT
    即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。
    全文索引并不是和MyISAM一起诞生的，它的出现是为了解决WHERE name LIKE “%word%"这类针对文本的模糊查询效率较低的问题。
2. HASH
    由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。
    HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。
3. BTREE
    BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。
4. RTREE
    RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。

哈希索引和B+树索引比较
B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过1，而且同层级的节点间有指针相互链接。
哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。
从上面的图来看，B+树索引和哈希索引的明显区别是：
如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
哈希索引也不支持多列联合索引的最左匹配规则；
B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。


使用索引注意：
1、order by中的列是不会使用索引的。
2、通配符%在字符串的开端使得索引无法使用如 name like '%zhang' 而name like'zhang%'就可以。
3、or会引起全表扫描。
4、in的作用相对于or
    如：
    select * from table where id in(2,3)
    等于
    select * from table where id = 2 or id =3;如果id上有索引，则索引会失效。
5、尽量少用not。
6、exists 和 in 的执行效率是一样的。
7、union并不绝对比or的执行效率高。
    如：
    select id,name from table where time='2012-01-01' or age =22
    等于
    select id,name from table where time ='2012-01-01' union select id,name from table where age = 22
    但是如果or两边的查询条件是一样的话，那么用union则反倒速度差很多。虽然这里union扫描的是索引，而
    or扫描的是全表。
    如：select * from table where id = 2 or id = 3;
8、字段提取要按照“需多少、提多少”的原则，避免“select *”
9、count(*)不比count(字段)慢
    1）在表没有主键时，count(1)比count(*)快；
    2）有主键时，主键作为计算条件，count(主键)效率最高；
    3）若表格只有一个字段，则count(*)效率较高。
10、orderby按聚集索引列排序效率最高,如果按照某个字段进行排序的时候，无论是倒序还是顺序，速度是相当的。
11、charindex
    查询a字段中包含b的所有行
    select * from table where a like '%b%'
    等于
    select * from table where charindex('b',a)>0 这种方法比like的形式速度上要快很多。
12、请选择与业务无关的自增字段作为主键。
这样就会形成一个紧凑的索引结构，近似顺序填满，由于每次插入时也不需要移动已有数据，因此效率很高，
也不会增加很多开销在维护索引上。
如果使用非自增主键（如果身份证或学号），由于每次插入主键的值近似于随机，因此每次新记录都要被
查到现有索引页的中间某个位置。此时mysql不得不为了将新记录插到合适位置而移动数据，甚至目标页面
可能已经被写到磁盘上而从缓存中清掉，此时也要从磁盘上读回来，这增加了很多开销，同时频繁的移动，
分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过optimize table来重建表
并优化填充页面。
13、每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加贵。聚集索引的优点：迅速缩小查询范围，避免全表扫描。
